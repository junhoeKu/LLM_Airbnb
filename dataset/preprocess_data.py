# -*- coding: utf-8 -*-
"""preprocess_data(전처리추가)

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19NV8COYjkhjBmuNZdhXjE2uaJg3lEvpb
"""


import pandas as pd
import numpy as np
import re
import matplotlib.pyplot as plt
import seaborn as sns

## Dataset Load
overview1 = pd.read_csv('/content/drive/MyDrive/dataset/AirbnbOverview.csv')
overview2 = pd.read_csv('/content/drive/MyDrive/dataset/AirbnbOverview2.csv')
amenity = pd.read_csv('/content/drive/MyDrive/dataset/Amenities_20012025.csv')
calendar1 = pd.read_csv('/content/drive/MyDrive/dataset/Calendar_11122024.csv')
calendar2 = pd.read_csv('/content/drive/MyDrive/dataset/Calendar_18012025.csv')
description = pd.read_csv('/content/drive/MyDrive/dataset/Description_20012025.csv')
pricing1 = pd.read_csv('/content/drive/MyDrive/dataset/Pricing_11122024.csv')
pricing2 = pd.read_csv('/content/drive/MyDrive/dataset/Pricing_20012025.csv')
review = pd.read_csv('/content/drive/MyDrive/dataset/Reviews_20012025.csv')
data = pd.read_excel('/content/drive/MyDrive/dataset/DataDictionary.xlsx')

review.head()

## Dataset Concat
# 1은 2024년 12월 11일까지의 데이터 2는 2025년 1월 20일까지의 데이터 이 2개를 합치는 곳보다 데이터 2에 데이터 1을 합치는 방향이 나을듯
## overview
# 먼저 두 개의 데이터를 concat으로 합쳐서 전체 listing ID 빈도 확인
overview_all = pd.concat([overview1, overview2])
listing_counts = overview_all['Airbnb_ListingID'].value_counts()
# ID별로 몇 번 나오는지 판단해서 조건 분기
ids_appeared_twice = listing_counts[listing_counts == 2].index
ids_appeared_once = listing_counts[listing_counts == 1].index
# 조건에 맞게 데이터 선택
overview = pd.concat([
    overview2[overview2['Airbnb_ListingID'].isin(ids_appeared_twice)],
    overview1[overview1['Airbnb_ListingID'].isin(ids_appeared_once)]
], ignore_index=True)

## calendar
# 날짜 기준 설정
cutoff_date = pd.to_datetime("2025-01-18")
# datetime 타입으로 변환 (혹시 문자열일 경우 대비)
calendar1['Calendar_Date'] = pd.to_datetime(calendar1['Calendar_Date'])
calendar2['Calendar_Date'] = pd.to_datetime(calendar2['Calendar_Date'])
# 조건에 맞게 필터링
calendar1_filtered = calendar1[calendar1['Calendar_Date'] <= cutoff_date]
calendar2_filtered = calendar2[calendar2['Calendar_Date'] > cutoff_date]
# 병합
calendar = pd.concat([calendar1_filtered, calendar2_filtered], ignore_index=True)

## pricing
# 기준 날짜 설정
cutoff_date = pd.to_datetime("2025-01-20")

# datetime 변환 (문자열일 수 있으므로 안전하게 변환)
pricing1['Stay_Checkout'] = pd.to_datetime(pricing1['Stay_Checkout'])
pricing2['Stay_Checkout'] = pd.to_datetime(pricing2['Stay_Checkout'])

# 조건에 맞게 필터링
pricing1_filtered = pricing1[pricing1['Stay_Checkout'] < cutoff_date]
pricing2_filtered = pricing2[pricing2['Stay_Checkout'] >= cutoff_date]

# 병합
pricing = pd.concat([pricing1_filtered, pricing2_filtered], ignore_index=True)

## overview & description

overview = overview.dropna(subset=['Airbnb_ListingID'])
description = description.dropna(subset=['Airbnb_ListingID'])
overview = overview.dropna(subset=['Host_ID'])
description = description.dropna(subset=['Host_ID'])



# Airbnb_ListingID와 Host_ID 모두 문자열로 통일
description['Airbnb_ListingID'] = pd.to_numeric(description['Airbnb_ListingID'], errors='coerce')
overview['Airbnb_ListingID'] = pd.to_numeric(overview['Airbnb_ListingID'], errors='coerce')

description['Host_ID'] = pd.to_numeric(description['Host_ID'], errors='coerce')
overview['Host_ID'] = pd.to_numeric(overview['Host_ID'], errors='coerce')
overview['Host_ID'] = overview['Host_ID'].astype(float)

des_over = overview.merge(
    description,
    on=['Airbnb_ListingID'],
    how='inner',
    suffixes=('_review', '_desc')
)

print(des_over.isnull().sum().to_string())

des_over['Lat']

## calendar & pricing

# 1. 날짜 타입 맞추기
calendar['Calendar_Date'] = pd.to_datetime(calendar['Calendar_Date'])
pricing['Stay_Checkin'] = pd.to_datetime(pricing['Stay_Checkin'])
pricing['Stay_Checkout'] = pd.to_datetime(pricing['Stay_Checkout'])

# 2. pricing 확장: 체크인~체크아웃 날짜 별로 풀기 (체크아웃 전날까지)
pricing_expanded = []
for _, row in pricing.iterrows():
    stay_dates = pd.date_range(
        start=row['Stay_Checkin'],
        end=row['Stay_Checkout'] - pd.Timedelta(days=1),
        freq='D'
    )
    for date in stay_dates:
        pricing_expanded.append({
            'Airbnb_ListingID': row['Airbnb_ListingID'],
            'Calendar_Date': date.normalize(),  # 날짜 단위만 사용
            'Guests': row['Guests'],  # 👈 Guests 인원 추가
            'Price_Per_Night': row['Price_Per_Night'],
            'Cleaning_Fee': row['Cleaning_Fee'],
            'Airbnb_Service_Fee': row['Airbnb_Service_Fee'],
            'Taxes': row['Taxes']
        })

pricing_expanded_df = pd.DataFrame(pricing_expanded)

# 3. calendar와 병합 (날짜 단위 정확히 매칭)
calendar['Calendar_Date'] = calendar['Calendar_Date'].dt.normalize()
cal_pri = calendar.merge(
    pricing_expanded_df,
    on=['Airbnb_ListingID', 'Calendar_Date'],
    how='left'
)

# 4. Price_Per_Night가 NaN인 행 제거
cal_pri = cal_pri[cal_pri['Price_Per_Night'].notna()].reset_index(drop=True)

# Step 1: Airbnb_ListingID별 Cleaning_Fee 평균값 계산 (NaN 제외)
cleaning_fee_map = cal_pri.groupby('Airbnb_ListingID')['Cleaning_Fee'].transform(
    lambda x: x.fillna(method='ffill').fillna(method='bfill')
)

# Step 2: 해당 값을 우선 채우고, 여전히 NaN이면 0으로 대체
cal_pri['Cleaning_Fee'] = cal_pri['Cleaning_Fee'].fillna(cleaning_fee_map)
cal_pri['Cleaning_Fee'] = cal_pri['Cleaning_Fee'].fillna(0)

pricing_expanded_df

print(cal_pri.isnull().sum().to_string())

cal_pri.head()

## review 전처리
review = review.dropna(subset=['Airbnb_ListingID'])
review['Airbnb_ListingID'] = pd.to_numeric(review['Airbnb_ListingID'], errors='coerce')
review['Rating'] = pd.to_numeric(review['Rating'], errors='coerce')
review = review.dropna(subset=['Rating'])
review['Rating'] = review['Rating'].astype(int)

columns_for_rag_summary = [
    # 위치 및 기본 정보
    'Airbnb_ListingID', 'Location', 'City', 'LocalizedNeighborhood','Lat','Lng'
    # 공간 구성
    'Bedrooms', 'Beds', 'Bathrooms', 'PersonCapacity',

    # 가격
    'Price_Per_Night', 'Cleaning_Fee', 'Taxes','total_price'

    # 숙소/공간 타입
    'RoomType_Clean', 'SpaceType_Clean',

    # 호스트 관련
    'Host_isSuperhost', 'Host_ResponseRate', 'Host_ResponseTime','HostLanguages_Verbose'

    # 편의시설
    'amenities_SelfCheckIn','CheckIn_Start','CheckOut_End'

    # 감성/분위기 관련 텍스트
    'ListingTitle_Localized', 'MainDescription_Localized', 'SpaceDescription_Localized',
    'PhotoCaptions_Localized', 'Host_Highlights', 'HostAbout_Localized',

    # 리뷰
    'ReviewScore', 'StarRating', 'ReviewCount', 'ReviewComments_Localized',

    # 기타
    'PictureCount'
]

"""# 1. 숙소 제목 정리"""

des_over.head()

title_df= des_over[['Airbnb_ListingID','Title']]
title_df['Title'] = title_df['Title'].fillna("")
title_df

"""# 2. 숙소 위치 정리"""

location_df = des_over[['Airbnb_ListingID', 'Location','Lat','Lng','LocalizedNeighbourhood_ML','LocationDescription']]
location_df['LocationDescription'] = location_df['LocationDescription'].fillna("")

"""# 3. 숙소 정보 정리"""

infor_df=des_over[['Airbnb_ListingID','MainDescription','SpaceDescription','GuestAccessDescription']]
infor_df['MainDescription'] = infor_df['MainDescription'].fillna("")
infor_df['SpaceDescription'] = infor_df['SpaceDescription'].fillna("")
infor_df['GuestAccessDescription'] = infor_df['GuestAccessDescription'].fillna("")
infor_df

"""# 4. 숙소 구성 정리"""

from tqdm import tqdm

tqdm.pandas()
amenity_df = amenity.copy()

## 어메니티 컬럼들만 선택 (Airbnb_ListingID 및 기본 컬럼 제외)
amenity_cols = amenity_df.columns.difference(['Location', 'Country', 'Airbnb_ListingID', 'RecordInserted'])

## 어메니티가 있는 경우를 True로 바꾸기
amenity_binary = amenity_df[amenity_cols].fillna(0).astype(int)

## True인 컬럼 이름만 리스트로 추출
def get_amenities(row):
    return ', '.join([col for col in amenity_binary.columns if row[col] == 1])

amenity_df['Amenities'] = amenity_binary.progress_apply(get_amenities, axis=1)
amenity_df = amenity_df[['Airbnb_ListingID', 'Amenities']]

## amenity_df merge
amenity_df = amenity_df[['Airbnb_ListingID', 'Amenities']]
amenity_df = des_over[['Airbnb_ListingID', 'Bathrooms', 'Bedrooms', 'Beds', 'PersonCapacity']].merge(amenity_df, on = 'Airbnb_ListingID', how = 'inner')

## 겹치는 숙소 ID 제거
amenity_df = amenity_df.drop_duplicates(subset='Airbnb_ListingID', keep='first')
amenity_df = amenity_df.fillna(0)
amenity_df

"""# 5. 숙소 가격 정리

"""

# Calendar_Date를 기준으로 해야 예약여부랑 가격을 정리 할 수 있을듯
cal_pri.head()

# 삭제할 컬럼 리스트
cols_to_drop = ['Country', 'Location', 'Calendar_Month', 'Calendar_Year', 'Stay_Week', 'RecordInserted', 'Taxes']

# 실제 존재하는 컬럼만 남기고 드롭
cal_pri.drop(columns=[col for col in cols_to_drop if col in cal_pri.columns], inplace=True)

Airbnb_Servic_map = cal_pri.groupby('Airbnb_ListingID')['Airbnb_Service_Fee'].transform(
    lambda x: x.fillna(method='ffill').fillna(method='bfill')
)

# Step 2: 해당 값을 우선 채우고, 여전히 NaN이면 0으로 대체
cal_pri['Airbnb_Service_Fee'] = cal_pri['Airbnb_Service_Fee'].fillna(Airbnb_Servic_map)
cal_pri['Airbnb_Service_Fee'] = cal_pri['Airbnb_Service_Fee'].fillna(0)

# 우선 Calendar_Date를 datetime 타입으로 변환
cal_pri['Calendar_Date'] = pd.to_datetime(cal_pri['Calendar_Date'])

def compress_by_month(sub_df):
    """Airbnb_ListingID별, 월별 예약 가능일 요약"""
    available_dates = sub_df[sub_df['isAvailable']]['Calendar_Date'].sort_values()

    if available_dates.empty:
        return ""

    available_dates = available_dates.dt.to_period('D')  # 날짜만 남기기
    month_groups = {}

    for date in available_dates:
        month = date.strftime('%m월')
        day = int(date.strftime('%d'))
        month_groups.setdefault(month, []).append(day)

    # 요약 포맷
    summary = []
    for month, days in month_groups.items():
        days.sort()
        compressed = []
        start = prev = days[0]
        for d in days[1:]:
            if d == prev + 1:
                prev = d
            else:
                compressed.append(f"{start}-{prev}" if start != prev else f"{start}")
                start = prev = d
        compressed.append(f"{start}-{prev}" if start != prev else f"{start}")
        summary.append(f"{month}: {', '.join(map(str, compressed))}")

    return "; ".join(summary)


# Airbnb_ListingID 별로 그룹화 후, Available_Ranges 컬럼 생성
available_ranges_df = cal_pri.groupby('Airbnb_ListingID').apply(compress_by_month).reset_index()
available_ranges_df.columns = ['Airbnb_ListingID', 'Available_Ranges']

# 원본 cal_pri에 merge
cal_pri = cal_pri.merge(available_ranges_df, on='Airbnb_ListingID', how='left')

cal_pri

# 가격 컬럼들을 숫자형으로 변환
price = ['Price_Per_Night', 'Cleaning_Fee', 'Airbnb_Service_Fee']
for col in price:
    cal_pri[col] = pd.to_numeric(cal_pri[col].astype(str).str.replace(r'[^\d.]', '', regex=True), errors='coerce')

# 숙소별 평균 가격 계산
cal_pri_additional = cal_pri.groupby('Airbnb_ListingID').agg({
    'Price_Per_Night': 'mean',
    'Cleaning_Fee': 'mean',
    'Airbnb_Service_Fee': 'mean'
}).reset_index()

# 컬럼명 변경 (optional)
cal_pri_additional.rename(columns={
    'Price_Per_Night': 'Price_Per_Night_mean',
    'Cleaning_Fee': 'Cleaning_Fee_mean',
    'Airbnb_Service_Fee': 'Airbnb_Service_Fee_mean'
}, inplace=True)

# 원본 cal_pri에 merge
cal_pri = cal_pri.merge(cal_pri_additional, on='Airbnb_ListingID', how='left')

cal_pri

cal_pri['total_price'] = cal_pri['Price_Per_Night'] + cal_pri['Cleaning_Fee'] + cal_pri['Airbnb_Service_Fee']

cal_pri['total_price_mean'] = cal_pri['Price_Per_Night_mean'] + cal_pri['Cleaning_Fee_mean'] + cal_pri['Airbnb_Service_Fee_mean']

cal_pri.head()

"""# 6. 숙소 유형 정리"""

## 겹치는 숙소 ID 제거
type_df = des_over[['Airbnb_ListingID', 'RoomType_Clean', 'SpaceType_Clean']]
type_df

"""# 7. 슈퍼호스트 여부"""

## 결측치 제거
superhost_df = des_over[['Airbnb_ListingID','isSuperhost', 'Host_ResponseRate', 'Host_ResponseTime','HostLanguages_Verbose']]
superhost_df['Host_ResponseRate'].fillna("", inplace=True)
superhost_df['Host_ResponseTime'].fillna("", inplace=True)
superhost_df['HostLanguages_Verbose'].fillna("", inplace=True)
superhost_df

"""# 8.편의성 정리"""

checkin_df = des_over[['Airbnb_ListingID', 'amenities_SelfCheckIn', 'CheckIn_Start', 'CheckOut_End']]
# 결측치 채우기
checkin_df['amenities_SelfCheckIn'].fillna("", inplace=True)
checkin_df['CheckIn_Start'].fillna("", inplace=True)
checkin_df['CheckOut_End'].fillna("", inplace=True)

"""# 7. 숙소 리뷰 정리"""

import pandas as pd
import re

pd.set_option('display.max_colwidth', 100)

def clean_text(text):
    # 1. 한글, 숫자, 공백, 문장부호(.,?!만 남기기)
    text = re.sub(r'[^가-힣0-9\s\.\,\?\!]', ' ', str(text))

    # 2. 여러 공백 → 하나의 공백으로 줄이기
    text = re.sub(r'\s{2,}', ' ', text)

    # 3. 좌우 공백 제거
    return text.strip()

# ✅ 결측치 제거
review_df = review[['Airbnb_ListingID', 'ReviewLanguage', 'ReviewComments', 'Rating']]
review_df = review_df[review_df['ReviewLanguage'] == 'ko'].dropna(subset=['ReviewComments', 'Rating'])
review_df['ReviewComments'] = review_df['ReviewComments'].apply(clean_text)

# ✅ 리뷰 병합
grouped_comments = review_df.groupby('Airbnb_ListingID')['ReviewComments'].apply(lambda x: ' '.join(x)).reset_index()

# ✅ 평점 평균
grouped_rating = review_df.groupby('Airbnb_ListingID')['Rating'].mean().reset_index()

# ✅ 리뷰 개수
grouped_comments_counts = review_df.groupby('Airbnb_ListingID')['Rating'].size().reset_index()
grouped_comments_counts.columns = ['Airbnb_ListingID', 'ReviewCounts']

# ✅ 결합
review_summary_input = grouped_comments.merge(grouped_rating, on='Airbnb_ListingID') \
                                       .merge(grouped_comments_counts, on='Airbnb_ListingID')

# ✅ 리뷰 길이 필터
review_summary_input['Review_Length'] = review_summary_input['ReviewComments'].apply(lambda x: len(x))
review_summary_input = review_summary_input[review_summary_input['Review_Length'] > 0]

def generate_better_summary(text, max_len=100):
    if pd.isna(text) or not isinstance(text, str) or len(text.strip()) == 0:
        return ""

    # 문장 구분자로 자르기 (.!? 포함)
    sentences = re.split(r'(?<=[\.\!\?])\s+', text.strip())
    summary = ""

    # 문장이 1개 이상 있을 경우
    if len(sentences) >= 2:
        summary = sentences[0]
        # 문장이 너무 짧으면 두 번째 문장까지 포함
        if len(summary) < 30:
            summary += " " + sentences[1]
    elif len(sentences) == 1:
        summary = sentences[0]
    else:
        return text[:max_len] + '...'

    # 너무 길면 자르기
    return summary if len(summary) <= max_len else summary[:max_len].strip() + '...'
review_summary_input['ReviewSummary'] = review_summary_input['ReviewComments'].apply(generate_better_summary)

review_summary_input

"""# 8. 종합"""

final_df = title_df \
    .merge(location_df, on='Airbnb_ListingID', how='left') \
    .merge(infor_df, on='Airbnb_ListingID', how='left') \
    .merge(amenity_df, on='Airbnb_ListingID', how='left') \
    .merge(type_df, on='Airbnb_ListingID', how='left') \
    .merge(superhost_df, on='Airbnb_ListingID', how='left') \
    .merge(checkin_df, on='Airbnb_ListingID', how='left') \
    .merge(review_summary_input, on='Airbnb_ListingID', how='inner')

final_df_all = cal_pri.merge(
    final_df,
    on='Airbnb_ListingID',
    how='left'
)

## 리뷰 요약 Nan의 경우 그냥 리뷰로 사용
final_df_all['ReviewSummary'] = final_df_all['ReviewSummary'].fillna(final_df_all['ReviewComments'])

## 모든 결측치가 Hotel의 경우라서 Hotel로 대체
final_df_all['RoomType_Clean'] = final_df_all['RoomType_Clean'].fillna('Hotel')

## 이름, 리뷰가 없는 경우 제거
final_df_all = final_df_all.dropna(subset=['Title', 'ReviewComments'])

## 리뷰 요약 Nan의 경우 그냥 리뷰로 사용
final_df['ReviewSummary'] = final_df['ReviewSummary'].fillna(final_df['ReviewComments'])

## 모든 결측치가 Hotel의 경우라서 Hotel로 대체
final_df['RoomType_Clean'] = final_df['RoomType_Clean'].fillna('Hotel')

## 이름, 리뷰가 없는 경우 제거
final_df = final_df.dropna(subset=['Title', 'ReviewComments'])

# cal_pri의 컬럼 리스트 추출
columns_to_keep = cal_pri.columns.tolist()

# final_df_all에서 해당 컬럼만 추출
final_price_df = final_df_all[columns_to_keep]

print("cal_pri shape:", cal_pri.shape)
print("final_df shape:", final_df.shape)
print("final_df_all shape:", final_df_all.shape)
print("final_price_df shape:", final_price_df.shape)

print(final_df.isnull().sum().to_string())

final_df[final_df.Airbnb_ListingID == 48689803]

print(final_price_df .isnull().sum().to_string())

final_price_df .head()

final_df.to_csv('/content/drive/MyDrive/dataset/final(0502).csv', index=False)

print(final_df.isnull().sum().to_string())

final_price_df.to_csv('/content/drive/MyDrive/dataset/final_price(0502).csv', index=False)

print(final_price_df.isnull().sum().to_string())

