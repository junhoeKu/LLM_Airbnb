# -*- coding: utf-8 -*-
"""df_to_pickle.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17xtdq1QHCn2US8R8oAlhDVgDBacT3T4r
"""


import pandas as pd
import pickle
import numpy as np

# 데이터 불러오기
final_df = pd.read_csv("/content/drive/MyDrive/dataset/final(0519).csv")

# 결측치 처리
final_df["Title"].fillna("제목 미입력", inplace=True)
final_df["LocationDescription"].fillna("위치 정보 없음", inplace=True)
final_df["MainDescription"].fillna("상세 설명 없음", inplace=True)
final_df["SpaceDescription"].fillna("공간 설명 없음", inplace=True)
final_df["GuestAccessDescription"].fillna("이용 가능 공간 정보 없음", inplace=True)
final_df["Host_ResponseRate"].fillna("응답률 정보 없음", inplace=True)
final_df["Host_ResponseTime"].fillna("응답 시간 정보 없음", inplace=True)
final_df["amenities_SelfCheckIn"].fillna("셀프 체크인 여부 모름", inplace=True)
final_df["CheckIn_Start"].fillna("체크인 시간 모름", inplace=True)
final_df["CheckOut_End"].fillna("체크아웃 시간 모름", inplace=True)

# 매핑 딕셔너리 정의
neighborhood_mapping = {
    "Ma-po-gu": "마포구",
    "Yong-san-gu": "용산구",
    "Yongsan-gu": "용산구",
    "Gang-nam-gu": "강남구",
    "Jong-no-gu": "종로구",
    "Jung-gu": "중구",
    "Myeong-dong": "명동",
    "Gwa-nak-gu": "관악구",
    "Yeong-deung-po-gu": "영등포구",
    "Gwang-jin-gu": "광진구",
    "Seo-cho-gu": "서초구",
    "Seocho-gu": "서초구",
    "Dong-dae-mun-gu": "동대문구",
    "Song-pa-gu": "송파구",
    "Seo-dae-mun-gu": "서대문구",
    "Seong-buk-gu": "성북구",
    "Eun-pyeong-gu": "은평구",
    "Seong-dong-gu": "성동구",
    "Dong-jak-gu": "동작구",
    "Gang-buk-gu": "강북구",
    "Sin-chon-dong": "신촌동",
    "Jung-nang-gu": "중랑구",
    "Seong-su 2 ga 1 dong": "성수2가1동",
    "Gu-ro-gu": "구로구",
    "Geum-cheon-gu": "금천구",
    "No-won-gu": "노원구",
    "Do-bong-gu": "도봉구",
    "Goyang-si": "고양시"
}

def map_neighborhood_to_korean(name: str) -> str:
    return neighborhood_mapping.get(name, name)  # 없는 값은 그대로 반환

# 새 컬럼 생성
final_df["LocalizedNeighbourhood_ML"] = final_df["LocalizedNeighbourhood_ML"].apply(map_neighborhood_to_korean)

# Calendar_Date를 datetime으로 변환하고 month 컬럼 추가
final_df['Calendar_Date'] = pd.to_datetime(final_df['Calendar_Date'])
final_df['month'] = final_df['Calendar_Date'].dt.month

def compress_days_only(sub_df):
    """Airbnb_ListingID별 월별 예약 가능일 요약"""
    available_dates = sub_df[sub_df['isAvailable']]['Calendar_Date'].sort_values()

    if available_dates.empty:
        return ""

    days = available_dates.dt.day.tolist()
    days.sort()

    compressed = []
    start = prev = days[0]
    for d in days[1:]:
        if d == prev + 1:
            prev = d
        else:
            compressed.append(f"{start}-{prev}" if start != prev else f"{start}")
            start = prev = d
    compressed.append(f"{start}-{prev}" if start != prev else f"{start}")

    return ", ".join(map(str, compressed))

# Airbnb_ListingID, month 단위로 그룹화
available_ranges_df = (
    final_df
    .groupby(['Airbnb_ListingID', 'month'])
    .apply(compress_days_only)
    .reset_index()
)

available_ranges_df.columns = ['Airbnb_ListingID', 'month', 'Available_Ranges']

# 월별 예약 가능 요약이 포함된 price_df로 merge
price_df = final_df.merge(available_ranges_df, on=['Airbnb_ListingID', 'month'], how='left')

final_df['dayofweek'] = final_df['Calendar_Date'].dt.dayofweek
price_df = price_df[['Airbnb_ListingID', 'month', 'dayofweek', 'Guests', 'Price_Per_Night', 'Cleaning_Fee', 'Airbnb_Service_Fee', 'total_price', 'Available_Ranges_y']]

price_df

price_mean = price_df[['Airbnb_ListingID', 'month', 'dayofweek', 'Guests', 'Price_Per_Night', 'Cleaning_Fee', 'Airbnb_Service_Fee', 'total_price']].groupby(['Airbnb_ListingID', 'month', 'dayofweek']).mean().reset_index().applymap(lambda x: round(x, 0))
price_max = price_mean[['Airbnb_ListingID', 'total_price']].groupby('Airbnb_ListingID').mean().reset_index().applymap(lambda x: round(x, 0))
price_max.columns = ['Airbnb_ListingID', 'total_price_mean']
price_range = price_df[['Airbnb_ListingID', 'month', 'Available_Ranges_y']]
price_range.columns = ['Airbnb_ListingID', 'month', 'Available_Ranges']
price_range = price_range.drop_duplicates(['Airbnb_ListingID', 'month'])

price_mean = price_mean.merge(price_range, on=['Airbnb_ListingID', 'month'], how='left').merge(price_max, on = ['Airbnb_ListingID'], how = 'left')

price_mean

price_mean.head(2)

price_mean

price_mean["price_comment"] = price_mean.apply(
    lambda row: (
        "평소 수준의 요금입니다."
        if abs((row["total_price"] - row["total_price_mean"]) / row["total_price_mean"] * 100) <= 5 else
        "평소보다 저렴한 편입니다."
        if (row["total_price"] - row["total_price_mean"]) / row["total_price_mean"] * 100 < -5 else
        "평소보다 다소 높은 편입니다."
    ) + (
        " 특가 숙소로 분류됩니다.\n"
        if (row["total_price"] - row["total_price_mean"]) / row["total_price_mean"] * 100 < -20 else ""
    ),
    axis=1
)

# ✅ 1. CSV -> Pickle 변환 + FAISS 준비용 벡터 저장 스크립트
import pandas as pd
import pickle
from sentence_transformers import SentenceTransformer
import numpy as np

embedding_model = SentenceTransformer("jhgan/ko-sroberta-multitask")

# 임베딩 텍스트 구성 함수
def build_embedding_text(row):
    # 가격 차이 및 변화율 계산
    price_diff = row['total_price'] - row['total_price_mean']
    price_change_ratio = (price_diff / row['total_price_mean']) * 100 if row['total_price_mean'] else 0

    # 요금 비교 문구 ('평소' 기준 ±5% 허용)
    if abs(price_change_ratio) <= 5:
        price_comment = "평소 수준의 요금입니다."
    elif price_change_ratio < -5:
        price_comment = "평소보다 저렴한 편입니다."
    else:
        price_comment = "평소보다 다소 높은 편입니다."

    # 특가 여부 태그
    special_offer_note = " 특가 숙소로 분류됩니다.\n" if price_change_ratio < -20 else ""

    return (
        f"리스팅ID: {row['Airbnb_ListingID']}\n"
        f"{row['month']}월의 예약가능 날짜 : {row['Available_Ranges']}\n"
        f"예약 인원: {row['Guests']}명\n"
        f"1박 요금: {row['Price_Per_Night']}원\n"
        f"청소비: {row['Cleaning_Fee']}원 / 에어비앤비 수수료: {row['Airbnb_Service_Fee']}원\n"
        f"1박 총요금: {row['total_price']}원\n"
        f"요금 비교: {price_comment} (평소 대비 {price_change_ratio:.1f}% {'상승' if price_change_ratio > 0 else '하락' if price_change_ratio < 0 else '변동 없음'})\n"
        f"{special_offer_note}"
    )

# 임베딩 텍스트와 벡터 생성
price_mean['embedding_text'] = price_mean.apply(build_embedding_text, axis=1)

embeddings = embedding_model.encode(price_mean['embedding_text'].tolist(), show_progress_bar=True, batch_size=64)

# numpy array로 변환
dense_vectors = np.array(embeddings)

# 저장 (Listing ID 포함 DF 유지)
with open("/content/drive/MyDrive/dataset/airbnb_data_price_요일추가.pkl", "wb") as f:
    pickle.dump({
        "df": price_mean[['Airbnb_ListingID', 'embedding_text'] +
                      [c for c in price_mean.columns if c not in ['Airbnb_ListingID', 'embedding_text']]],
        "vectors": dense_vectors
    }, f)

print("✅ Pickle 저장 완료: /content/drive/MyDrive/dataset/airbnb_data_price_요일추가.pkl")

